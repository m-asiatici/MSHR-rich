// See LICENSE for license details.

package fpgamshr.main

import chisel3._
import chisel3.util.{log2Ceil}
import fpgamshr.packaging._

import org.scalatest.{Matchers, FlatSpec}

import fpgamshr.profiling.{Profiling}
import java.io.{File, BufferedWriter, FileWriter} // To generate the .tcl and .h files
import scala.sys.process._ // for the ! operator


/**
  * To just generate the Verilog for the FPGAMSHR, run:
  * {{{
  * test:runMain fpgamshr.main.FPGAMSHRVerilog
  * }}}
  */

object FPGAMSHRVerilog extends App {
  FPGAMSHR.outputDir = "."
  FPGAMSHR.loadParams(if(args.length > 0) Some(args(0)) else None)
    chisel3.Driver.execute(args, () => new FPGAMSHR)
}

/**
  * This provides a way to run the firrtl-interpreter REPL (or shell)
  * on the lowered firrtl generated by your circuit. You will be placed
  * in an interactive shell. This can be very helpful as a debugging
  * technique. Type help to see a list of commands.
  *
  * To run from sbt
  * {{{
  * test:runMain fpgamshr.main.FPGAMSHRRepl
  * }}}
  * To run from sbt and see the half a zillion options try
  * {{{
  * test:runMain fpgamshr.main.FPGAMSHRRepl --help
  * }}}
  */
object FPGAMSHRRepl extends App {
  iotesters.Driver.executeFirrtlRepl(args, () => new FPGAMSHR)
}

object FPGAMSHRIpBuilder extends App {
  FPGAMSHR.outputDir = "."
  FPGAMSHR.loadParams(if(args.length > 0) Some(args(0)) else None)
  val myModelBuilder = new FPGAMSHRModelBuilder()
  myModelBuilder.main(Array[String]())
}

class FPGAMSHRModelBuilder extends ModuleBuilder(".") {
  val modules: List[ModuleDef] = List(
    ModuleDef(null, // test module
      () => new FPGAMSHR(),
      CoreDefinition(
        name    = FPGAMSHR.ipName,
        vendor  = "LAP",
        library = "FPGAMSHR",
        version = FPGAMSHR.version.toString,
        CoreDefinition.root(FPGAMSHR.ipName)
      )
    )
  )
}

object FPGAMSHRVivadoBuilder extends App {
  class MyFileWriter(path: String) {
    val file = new File(path)
    val bw = new BufferedWriter(new FileWriter(file))
    def write(str: String) = bw.write(str)
    def close() = bw.close()
  }
  if (! new File("output").exists) {
    "mkdir output" !
  }
  if (! new File("output/vivado").exists) {
    "mkdir output/vivado" !
  }
  FPGAMSHR.loadParams(if(args.length > 0) Some(args(0)) else None)
  val currentDateTime = s"""${java.time.LocalDate.now.toString} ${java.time.LocalTime.now.format(java.time.format.DateTimeFormatter.ofPattern("kk:mm:ss")).toString}"""
  val tclFile = new MyFileWriter("output/vivado/params.tcl")
  tclFile.write(s"# Generated on ${currentDateTime} with Chisel code version ${FPGAMSHR.version}\n")
  tclFile.write(s"""set fpgamshr_name "${FPGAMSHR.ipName}"\n""")
  tclFile.write("set run_compilation 1\n")
  tclFile.close()
  if (! new File("output/sw").exists) {
    "mkdir output/sw" !
  }
  val headerFile = new MyFileWriter("output/sw/params.h")
  headerFile.write(s"// Generated on ${currentDateTime} with Chisel code version ${FPGAMSHR.version}\n")
  headerFile.write(s"#define ADDR_BITS ${FPGAMSHR.reqAddrWidth}\n")
  headerFile.write(s"#define MEM_BASE_ADDR 0x${new scala.runtime.RichLong(FPGAMSHR.memAddrOffset).toHexString}\n")
  headerFile.write(s"#define ROB_DEPTH ${1 << FPGAMSHR.reqIdWidth}\n")
  headerFile.write(s"#define MSHR_HASH_TABLES ${FPGAMSHR.numHashTables}\n")
  headerFile.write(s"#define MSHR_PER_HASH_TABLE ${FPGAMSHR.numMSHRPerHashTable}\n")
  headerFile.write(s"#define SE_BUF_ENTRIES_PER_ROW ${FPGAMSHR.numSubentriesPerRow}\n")
  headerFile.write(s"#define SE_BUF_ROWS ${1 << FPGAMSHR.subentryAddrWidth}\n")
  headerFile.write(s"#define CACHE_WAYS ${FPGAMSHR.numCacheWays}\n")
  headerFile.write(s"#define CACHE_SIZE ${FPGAMSHR.cacheSizeBytes}\n")
  headerFile.write(s"#define CACHE_SIZE_REDUCTION_WIDTH ${FPGAMSHR.cacheSizeReductionWidth}\n")
  headerFile.write(s"#define NUM_REQ_HANDLERS ${FPGAMSHR.numReqHandlers}\n")
  headerFile.write(s"#define REGS_PER_REQ_HANDLER ${1 << (Profiling.regAddrWidth + Profiling.subModuleAddrWidth)}\n")
  headerFile.write(s"#define REGS_PER_REQ_HANDLER_MODULE ${1 << Profiling.regAddrWidth}\n")
  headerFile.write(s"#define FPGAMSHR_EXISTS 1\n")

  headerFile.close()
  "cp util/generator.tcl output/vivado" !
  // copy all files from sw to output/sw
  val f = (new File("sw")).listFiles.map(_.getName)
  for (file <- f) {s"cp sw/$file output/sw" !}
}
