;buildInfoPackage: chisel3, version: 3.1.2, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2018-07-25 16:52:17.431, builtAtMillis: 1532537537431
circuit AXISAndLenStream : 
  module ElasticBufferRegExportAXISAndLenStream : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, regs : {valid : UInt<1>, bits : UInt<2>}[2], readyReg : UInt<1>}
    
    reg outerRegData : UInt<2>, clock @[AXISAndLenStream.scala 34:27]
    reg outerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 35:32]
    reg innerRegData : UInt<2>, clock @[AXISAndLenStream.scala 36:27]
    reg innerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 37:32]
    reg readyReg : UInt<1>, clock @[AXISAndLenStream.scala 38:23]
    node _T_39 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 40:19]
    when _T_39 : @[AXISAndLenStream.scala 41:5]
      outerRegData <= io.in.bits @[AXISAndLenStream.scala 42:22]
      innerRegData <= outerRegData @[AXISAndLenStream.scala 43:22]
      outerRegValid <= io.in.valid @[AXISAndLenStream.scala 44:23]
      node _T_40 = not(io.out.valid) @[AXISAndLenStream.scala 45:59]
      node _T_41 = or(io.out.ready, _T_40) @[AXISAndLenStream.scala 45:57]
      node _T_42 = not(_T_41) @[AXISAndLenStream.scala 45:42]
      node _T_43 = and(outerRegValid, _T_42) @[AXISAndLenStream.scala 45:40]
      innerRegValid <= _T_43 @[AXISAndLenStream.scala 45:23]
      skip @[AXISAndLenStream.scala 41:5]
    node _T_45 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 47:33]
    node _T_46 = mux(_T_45, outerRegData, innerRegData) @[AXISAndLenStream.scala 47:23]
    io.out.bits <= _T_46 @[AXISAndLenStream.scala 47:17]
    node _T_48 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 48:34]
    node _T_49 = mux(_T_48, outerRegValid, innerRegValid) @[AXISAndLenStream.scala 48:24]
    io.out.valid <= _T_49 @[AXISAndLenStream.scala 48:18]
    node _T_50 = not(io.out.valid) @[AXISAndLenStream.scala 49:32]
    node _T_51 = or(io.out.ready, _T_50) @[AXISAndLenStream.scala 49:30]
    readyReg <= _T_51 @[AXISAndLenStream.scala 49:14]
    io.in.ready <= readyReg @[AXISAndLenStream.scala 50:17]
    io.regs[0].bits <= outerRegData @[AXISAndLenStream.scala 51:21]
    io.regs[0].valid <= outerRegValid @[AXISAndLenStream.scala 52:22]
    io.regs[1].bits <= innerRegData @[AXISAndLenStream.scala 53:21]
    io.regs[1].valid <= innerRegValid @[AXISAndLenStream.scala 54:22]
    io.readyReg <= readyReg @[AXISAndLenStream.scala 55:17]
    
  module ElasticBufferAXISAndLenStream : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}}
    
    inst fullBuffer of ElasticBufferRegExportAXISAndLenStream @[AXISAndLenStream.scala 21:28]
    fullBuffer.clock <= clock
    fullBuffer.reset <= reset
    fullBuffer.io.in.bits <= io.in.bits @[AXISAndLenStream.scala 22:22]
    fullBuffer.io.in.valid <= io.in.valid @[AXISAndLenStream.scala 22:22]
    io.in.ready <= fullBuffer.io.in.ready @[AXISAndLenStream.scala 22:22]
    io.out.bits <= fullBuffer.io.out.bits @[AXISAndLenStream.scala 23:12]
    io.out.valid <= fullBuffer.io.out.valid @[AXISAndLenStream.scala 23:12]
    fullBuffer.io.out.ready <= io.out.ready @[AXISAndLenStream.scala 23:12]
    
  module ElasticBufferRegExportAXISAndLenStream_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, regs : {valid : UInt<1>, bits : UInt<2>}[2], readyReg : UInt<1>}
    
    reg outerRegData : UInt<2>, clock @[AXISAndLenStream.scala 34:27]
    reg outerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 35:32]
    reg innerRegData : UInt<2>, clock @[AXISAndLenStream.scala 36:27]
    reg innerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 37:32]
    reg readyReg : UInt<1>, clock @[AXISAndLenStream.scala 38:23]
    node _T_39 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 40:19]
    when _T_39 : @[AXISAndLenStream.scala 41:5]
      outerRegData <= io.in.bits @[AXISAndLenStream.scala 42:22]
      innerRegData <= outerRegData @[AXISAndLenStream.scala 43:22]
      outerRegValid <= io.in.valid @[AXISAndLenStream.scala 44:23]
      node _T_40 = not(io.out.valid) @[AXISAndLenStream.scala 45:59]
      node _T_41 = or(io.out.ready, _T_40) @[AXISAndLenStream.scala 45:57]
      node _T_42 = not(_T_41) @[AXISAndLenStream.scala 45:42]
      node _T_43 = and(outerRegValid, _T_42) @[AXISAndLenStream.scala 45:40]
      innerRegValid <= _T_43 @[AXISAndLenStream.scala 45:23]
      skip @[AXISAndLenStream.scala 41:5]
    node _T_45 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 47:33]
    node _T_46 = mux(_T_45, outerRegData, innerRegData) @[AXISAndLenStream.scala 47:23]
    io.out.bits <= _T_46 @[AXISAndLenStream.scala 47:17]
    node _T_48 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 48:34]
    node _T_49 = mux(_T_48, outerRegValid, innerRegValid) @[AXISAndLenStream.scala 48:24]
    io.out.valid <= _T_49 @[AXISAndLenStream.scala 48:18]
    node _T_50 = not(io.out.valid) @[AXISAndLenStream.scala 49:32]
    node _T_51 = or(io.out.ready, _T_50) @[AXISAndLenStream.scala 49:30]
    readyReg <= _T_51 @[AXISAndLenStream.scala 49:14]
    io.in.ready <= readyReg @[AXISAndLenStream.scala 50:17]
    io.regs[0].bits <= outerRegData @[AXISAndLenStream.scala 51:21]
    io.regs[0].valid <= outerRegValid @[AXISAndLenStream.scala 52:22]
    io.regs[1].bits <= innerRegData @[AXISAndLenStream.scala 53:21]
    io.regs[1].valid <= innerRegValid @[AXISAndLenStream.scala 54:22]
    io.readyReg <= readyReg @[AXISAndLenStream.scala 55:17]
    
  module ElasticBufferAXISAndLenStream_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}}
    
    inst fullBuffer of ElasticBufferRegExportAXISAndLenStream_1 @[AXISAndLenStream.scala 21:28]
    fullBuffer.clock <= clock
    fullBuffer.reset <= reset
    fullBuffer.io.in.bits <= io.in.bits @[AXISAndLenStream.scala 22:22]
    fullBuffer.io.in.valid <= io.in.valid @[AXISAndLenStream.scala 22:22]
    io.in.ready <= fullBuffer.io.in.ready @[AXISAndLenStream.scala 22:22]
    io.out.bits <= fullBuffer.io.out.bits @[AXISAndLenStream.scala 23:12]
    io.out.valid <= fullBuffer.io.out.valid @[AXISAndLenStream.scala 23:12]
    fullBuffer.io.out.ready <= io.out.ready @[AXISAndLenStream.scala 23:12]
    
  module ElasticBufferRegExportAXISAndLenStream_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, regs : {valid : UInt<1>, bits : UInt<32>}[2], readyReg : UInt<1>}
    
    reg outerRegData : UInt<32>, clock @[AXISAndLenStream.scala 34:27]
    reg outerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 35:32]
    reg innerRegData : UInt<32>, clock @[AXISAndLenStream.scala 36:27]
    reg innerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 37:32]
    reg readyReg : UInt<1>, clock @[AXISAndLenStream.scala 38:23]
    node _T_39 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 40:19]
    when _T_39 : @[AXISAndLenStream.scala 41:5]
      outerRegData <= io.in.bits @[AXISAndLenStream.scala 42:22]
      innerRegData <= outerRegData @[AXISAndLenStream.scala 43:22]
      outerRegValid <= io.in.valid @[AXISAndLenStream.scala 44:23]
      node _T_40 = not(io.out.valid) @[AXISAndLenStream.scala 45:59]
      node _T_41 = or(io.out.ready, _T_40) @[AXISAndLenStream.scala 45:57]
      node _T_42 = not(_T_41) @[AXISAndLenStream.scala 45:42]
      node _T_43 = and(outerRegValid, _T_42) @[AXISAndLenStream.scala 45:40]
      innerRegValid <= _T_43 @[AXISAndLenStream.scala 45:23]
      skip @[AXISAndLenStream.scala 41:5]
    node _T_45 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 47:33]
    node _T_46 = mux(_T_45, outerRegData, innerRegData) @[AXISAndLenStream.scala 47:23]
    io.out.bits <= _T_46 @[AXISAndLenStream.scala 47:17]
    node _T_48 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 48:34]
    node _T_49 = mux(_T_48, outerRegValid, innerRegValid) @[AXISAndLenStream.scala 48:24]
    io.out.valid <= _T_49 @[AXISAndLenStream.scala 48:18]
    node _T_50 = not(io.out.valid) @[AXISAndLenStream.scala 49:32]
    node _T_51 = or(io.out.ready, _T_50) @[AXISAndLenStream.scala 49:30]
    readyReg <= _T_51 @[AXISAndLenStream.scala 49:14]
    io.in.ready <= readyReg @[AXISAndLenStream.scala 50:17]
    io.regs[0].bits <= outerRegData @[AXISAndLenStream.scala 51:21]
    io.regs[0].valid <= outerRegValid @[AXISAndLenStream.scala 52:22]
    io.regs[1].bits <= innerRegData @[AXISAndLenStream.scala 53:21]
    io.regs[1].valid <= innerRegValid @[AXISAndLenStream.scala 54:22]
    io.readyReg <= readyReg @[AXISAndLenStream.scala 55:17]
    
  module ElasticBufferAXISAndLenStream_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}}
    
    inst fullBuffer of ElasticBufferRegExportAXISAndLenStream_2 @[AXISAndLenStream.scala 21:28]
    fullBuffer.clock <= clock
    fullBuffer.reset <= reset
    fullBuffer.io.in.bits <= io.in.bits @[AXISAndLenStream.scala 22:22]
    fullBuffer.io.in.valid <= io.in.valid @[AXISAndLenStream.scala 22:22]
    io.in.ready <= fullBuffer.io.in.ready @[AXISAndLenStream.scala 22:22]
    io.out.bits <= fullBuffer.io.out.bits @[AXISAndLenStream.scala 23:12]
    io.out.valid <= fullBuffer.io.out.valid @[AXISAndLenStream.scala 23:12]
    fullBuffer.io.out.ready <= io.out.ready @[AXISAndLenStream.scala 23:12]
    
  module AXISAndLenStream : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rdAddr : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, rdData : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, flip wrAddr : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, flip wrData : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, wrAck : UInt<1>, offset : {valid : UInt<1>, bits : UInt<32>}, nnz : {valid : UInt<1>, bits : UInt<32>}, outputSize : {valid : UInt<1>, bits : UInt<32>}, running : UInt<1>, flip done : UInt<1>, flip rowPtrStream : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, lenStream : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}}
    
    reg state : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 79:24]
    node _T_84 = eq(state, UInt<1>("h01")) @[AXISAndLenStream.scala 80:25]
    io.running <= _T_84 @[AXISAndLenStream.scala 80:16]
    reg regs : UInt<32>[3], clock @[AXISAndLenStream.scala 82:19]
    wire start : UInt<1> @[AXISAndLenStream.scala 83:21]
    inst ElasticBufferAXISAndLenStream of ElasticBufferAXISAndLenStream @[AXISAndLenStream.scala 8:23]
    ElasticBufferAXISAndLenStream.clock <= clock
    ElasticBufferAXISAndLenStream.reset <= reset
    ElasticBufferAXISAndLenStream.io.in.bits <= io.rdAddr.bits @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream.io.in.valid <= io.rdAddr.valid @[AXISAndLenStream.scala 9:17]
    io.rdAddr.ready <= ElasticBufferAXISAndLenStream.io.in.ready @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream.io.out.ready <= io.rdData.ready @[AXISAndLenStream.scala 86:20]
    node _T_95 = eq(state, UInt<1>("h00")) @[AXISAndLenStream.scala 87:54]
    node _T_99 = eq(UInt<2>("h03"), ElasticBufferAXISAndLenStream.io.out.bits) @[Mux.scala 46:19]
    node _T_100 = mux(_T_99, regs[2], _T_95) @[Mux.scala 46:16]
    node _T_101 = eq(UInt<2>("h02"), ElasticBufferAXISAndLenStream.io.out.bits) @[Mux.scala 46:19]
    node _T_102 = mux(_T_101, regs[1], _T_100) @[Mux.scala 46:16]
    node _T_103 = eq(UInt<1>("h01"), ElasticBufferAXISAndLenStream.io.out.bits) @[Mux.scala 46:19]
    node _T_104 = mux(_T_103, regs[0], _T_102) @[Mux.scala 46:16]
    io.rdData.bits <= _T_104 @[AXISAndLenStream.scala 87:20]
    io.rdData.valid <= ElasticBufferAXISAndLenStream.io.out.valid @[AXISAndLenStream.scala 88:21]
    inst ElasticBufferAXISAndLenStream_1 of ElasticBufferAXISAndLenStream_1 @[AXISAndLenStream.scala 8:23]
    ElasticBufferAXISAndLenStream_1.clock <= clock
    ElasticBufferAXISAndLenStream_1.reset <= reset
    ElasticBufferAXISAndLenStream_1.io.in.bits <= io.wrAddr.bits @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream_1.io.in.valid <= io.wrAddr.valid @[AXISAndLenStream.scala 9:17]
    io.wrAddr.ready <= ElasticBufferAXISAndLenStream_1.io.in.ready @[AXISAndLenStream.scala 9:17]
    inst ElasticBufferAXISAndLenStream_2 of ElasticBufferAXISAndLenStream_2 @[AXISAndLenStream.scala 8:23]
    ElasticBufferAXISAndLenStream_2.clock <= clock
    ElasticBufferAXISAndLenStream_2.reset <= reset
    ElasticBufferAXISAndLenStream_2.io.in.bits <= io.wrData.bits @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream_2.io.in.valid <= io.wrData.valid @[AXISAndLenStream.scala 9:17]
    io.wrData.ready <= ElasticBufferAXISAndLenStream_2.io.in.ready @[AXISAndLenStream.scala 9:17]
    node wrAddrDataAvailable = and(ElasticBufferAXISAndLenStream_1.io.out.valid, ElasticBufferAXISAndLenStream_2.io.out.valid) @[AXISAndLenStream.scala 92:46]
    ElasticBufferAXISAndLenStream_1.io.out.ready <= ElasticBufferAXISAndLenStream_2.io.out.valid @[AXISAndLenStream.scala 93:20]
    ElasticBufferAXISAndLenStream_2.io.out.ready <= ElasticBufferAXISAndLenStream_1.io.out.valid @[AXISAndLenStream.scala 94:20]
    start <= UInt<1>("h00") @[AXISAndLenStream.scala 96:11]
    io.wrAck <= UInt<1>("h00") @[AXISAndLenStream.scala 97:14]
    when wrAddrDataAvailable : @[AXISAndLenStream.scala 98:31]
      node _T_110 = eq(ElasticBufferAXISAndLenStream_1.io.out.bits, UInt<1>("h00")) @[AXISAndLenStream.scala 99:26]
      when _T_110 : @[AXISAndLenStream.scala 99:35]
        node _T_111 = bits(ElasticBufferAXISAndLenStream_2.io.out.bits, 0, 0) @[AXISAndLenStream.scala 100:27]
        node _T_113 = eq(_T_111, UInt<1>("h01")) @[AXISAndLenStream.scala 100:31]
        when _T_113 : @[AXISAndLenStream.scala 100:40]
          start <= UInt<1>("h01") @[AXISAndLenStream.scala 101:17]
          skip @[AXISAndLenStream.scala 100:40]
        skip @[AXISAndLenStream.scala 99:35]
      io.wrAck <= UInt<1>("h01") @[AXISAndLenStream.scala 104:16]
      skip @[AXISAndLenStream.scala 98:31]
    node _T_117 = eq(ElasticBufferAXISAndLenStream_1.io.out.bits, UInt<1>("h01")) @[AXISAndLenStream.scala 108:49]
    node _T_118 = and(wrAddrDataAvailable, _T_117) @[AXISAndLenStream.scala 108:32]
    when _T_118 : @[AXISAndLenStream.scala 108:59]
      regs[0] <= ElasticBufferAXISAndLenStream_2.io.out.bits @[AXISAndLenStream.scala 109:19]
      skip @[AXISAndLenStream.scala 108:59]
    node _T_120 = eq(ElasticBufferAXISAndLenStream_1.io.out.bits, UInt<2>("h02")) @[AXISAndLenStream.scala 108:49]
    node _T_121 = and(wrAddrDataAvailable, _T_120) @[AXISAndLenStream.scala 108:32]
    when _T_121 : @[AXISAndLenStream.scala 108:59]
      regs[1] <= ElasticBufferAXISAndLenStream_2.io.out.bits @[AXISAndLenStream.scala 109:19]
      skip @[AXISAndLenStream.scala 108:59]
    node _T_123 = eq(ElasticBufferAXISAndLenStream_1.io.out.bits, UInt<2>("h03")) @[AXISAndLenStream.scala 108:49]
    node _T_124 = and(wrAddrDataAvailable, _T_123) @[AXISAndLenStream.scala 108:32]
    when _T_124 : @[AXISAndLenStream.scala 108:59]
      regs[2] <= ElasticBufferAXISAndLenStream_2.io.out.bits @[AXISAndLenStream.scala 109:19]
      skip @[AXISAndLenStream.scala 108:59]
    io.nnz.bits <= regs[0] @[AXISAndLenStream.scala 113:24]
    io.outputSize.bits <= regs[1] @[AXISAndLenStream.scala 114:24]
    io.offset.bits <= regs[2] @[AXISAndLenStream.scala 115:24]
    io.running <= UInt<1>("h00") @[AXISAndLenStream.scala 117:16]
    io.offset.valid <= UInt<1>("h00") @[AXISAndLenStream.scala 118:21]
    io.nnz.valid <= UInt<1>("h00") @[AXISAndLenStream.scala 119:18]
    io.outputSize.valid <= UInt<1>("h00") @[AXISAndLenStream.scala 120:25]
    node _T_129 = eq(UInt<1>("h00"), state) @[Conditional.scala 37:30]
    when _T_129 : @[Conditional.scala 40:58]
      when start : @[AXISAndLenStream.scala 124:21]
        state <= UInt<1>("h01") @[AXISAndLenStream.scala 125:17]
        io.offset.valid <= UInt<1>("h01") @[AXISAndLenStream.scala 126:27]
        io.nnz.valid <= UInt<1>("h01") @[AXISAndLenStream.scala 127:24]
        io.outputSize.valid <= UInt<1>("h01") @[AXISAndLenStream.scala 128:31]
        skip @[AXISAndLenStream.scala 124:21]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_133 = eq(UInt<1>("h01"), state) @[Conditional.scala 37:30]
      when _T_133 : @[Conditional.scala 39:67]
        io.running <= UInt<1>("h01") @[AXISAndLenStream.scala 132:20]
        when io.done : @[AXISAndLenStream.scala 133:23]
          state <= UInt<1>("h00") @[AXISAndLenStream.scala 134:17]
          skip @[AXISAndLenStream.scala 133:23]
        skip @[Conditional.scala 39:67]
    wire emptyData : {valid : UInt<1>, bits : UInt<32>} @[AXISAndLenStream.scala 139:25]
    emptyData.valid <= UInt<1>("h00") @[AXISAndLenStream.scala 140:21]
    emptyData.bits is invalid @[AXISAndLenStream.scala 141:21]
    wire _T_147 : {valid : UInt<1>, bits : UInt<32>}[2] @[AXISAndLenStream.scala 142:36]
    _T_147[0].bits <= emptyData.bits @[AXISAndLenStream.scala 142:36]
    _T_147[0].valid <= emptyData.valid @[AXISAndLenStream.scala 142:36]
    _T_147[1].bits <= emptyData.bits @[AXISAndLenStream.scala 142:36]
    _T_147[1].valid <= emptyData.valid @[AXISAndLenStream.scala 142:36]
    reg delayedRowPtr : {valid : UInt<1>, bits : UInt<32>}[2], clock with : (reset => (reset, _T_147)) @[AXISAndLenStream.scala 142:32]
    node _T_197 = not(delayedRowPtr[0].valid) @[AXISAndLenStream.scala 145:51]
    node _T_198 = or(io.lenStream.ready, _T_197) @[AXISAndLenStream.scala 145:49]
    node _T_199 = not(delayedRowPtr[1].valid) @[AXISAndLenStream.scala 145:77]
    node _T_200 = or(_T_198, _T_199) @[AXISAndLenStream.scala 145:75]
    io.rowPtrStream.ready <= _T_200 @[AXISAndLenStream.scala 145:27]
    when io.done : @[AXISAndLenStream.scala 146:19]
      delayedRowPtr[0].valid <= UInt<1>("h00") @[AXISAndLenStream.scala 147:30]
      skip @[AXISAndLenStream.scala 146:19]
    else : @[AXISAndLenStream.scala 148:89]
      node _T_202 = not(delayedRowPtr[0].valid) @[AXISAndLenStream.scala 148:38]
      node _T_203 = or(io.lenStream.ready, _T_202) @[AXISAndLenStream.scala 148:36]
      node _T_204 = not(delayedRowPtr[1].valid) @[AXISAndLenStream.scala 148:64]
      node _T_205 = or(_T_203, _T_204) @[AXISAndLenStream.scala 148:62]
      when _T_205 : @[AXISAndLenStream.scala 148:89]
        delayedRowPtr[0].bits <= io.rowPtrStream.bits @[AXISAndLenStream.scala 149:29]
        delayedRowPtr[0].valid <= io.rowPtrStream.valid @[AXISAndLenStream.scala 150:30]
        skip @[AXISAndLenStream.scala 148:89]
    when io.done : @[AXISAndLenStream.scala 152:19]
      delayedRowPtr[1].valid <= UInt<1>("h00") @[AXISAndLenStream.scala 153:30]
      skip @[AXISAndLenStream.scala 152:19]
    else : @[AXISAndLenStream.scala 154:63]
      node _T_207 = not(delayedRowPtr[1].valid) @[AXISAndLenStream.scala 154:38]
      node _T_208 = or(io.lenStream.ready, _T_207) @[AXISAndLenStream.scala 154:36]
      when _T_208 : @[AXISAndLenStream.scala 154:63]
        delayedRowPtr[1].bits <= delayedRowPtr[0].bits @[AXISAndLenStream.scala 155:24]
        delayedRowPtr[1].valid <= delayedRowPtr[0].valid @[AXISAndLenStream.scala 155:24]
        skip @[AXISAndLenStream.scala 154:63]
    node _T_209 = and(delayedRowPtr[1].valid, delayedRowPtr[0].valid) @[AXISAndLenStream.scala 157:50]
    io.lenStream.valid <= _T_209 @[AXISAndLenStream.scala 157:24]
    node _T_210 = sub(delayedRowPtr[0].bits, delayedRowPtr[1].bits) @[AXISAndLenStream.scala 158:49]
    node _T_211 = asUInt(_T_210) @[AXISAndLenStream.scala 158:49]
    node _T_212 = tail(_T_211, 1) @[AXISAndLenStream.scala 158:49]
    io.lenStream.bits <= _T_212 @[AXISAndLenStream.scala 158:24]
    
